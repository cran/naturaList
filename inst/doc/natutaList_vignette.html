<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Introduction to naturaList</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to naturaList</h1>



<p>The aim of <code>{naturaList}</code> package is to implement a
classification of occurrence records based on the suitability in the
species identification record. The quality of classification is ranked
up to six levels of confidence. Additionally, <code>{naturaList}</code>
package provides tools to filter the occurrence data based on these
classification levels, identify the possible specialists in the taxa and
evaluate the effects of the filtering procedure on different descriptors
of species spatial distribution of occurrence records (area of
distribution and niche breadth). With <code>{naturaList}</code> package
the users can filter large occurrence data based on well established and
clear criterion, evaluate possible effect of data processing on
downstream analysis and explore spatial occurrence data through an
interactive interface.</p>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p>Install the package:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&quot;naturaList&quot;</span>)</span></code></pre></div>
</div>
<div id="classify-occurrence-records-based-on-confidence-in-the-species-identification" class="section level2">
<h2>Classify occurrence records based on confidence in the species
identification</h2>
<p><code>{naturaList}</code> has as the core function
<code>classify_occ()</code>. The rationale of the classification is that
the most reliable identification of a specimen is made by a specialist
in the taxa. To classify an occurrence at this level of confidence, the
<code>classify_occ()</code> function needs of an occurrence and a
specialist dataset. The other levels in which data can be classified are
derived from information contained in the occurrence dataset. The
default order for classification in confidence levels is:</p>
<ul>
<li>Level 1 - species was identified by a specialist, if not;</li>
<li>Level 2 - who identified the species was a not specialist name, if
not;</li>
<li>Level 3 - occurrence record has an image associated, if not;</li>
<li>Level 4 - the specimen is preserved in a scientific collection, if
not;</li>
<li>Level 5 - the identification was done in filed observation, if
not;</li>
<li>Level 6 - no criteria was met.</li>
</ul>
<p>The user can alter this order, depending on his/her objectives,
except for the Level 1 that is always a species determined by a
specialist.</p>
<p>As example, we will use the datasets in <code>{naturaList}</code>:
<code>A.setosa</code>, as the occurrence dataset, and
<code>speciaLists</code>, as the specialist dataset. In the
<code>A.setosa</code> there are occurrence records for <em>Alsophila
setosa</em>, a tree fern of the Brazilian Atlantic Forest. This dataset
were downloaded from <a href="https://doi.org/10.15468/dl.6jesg0">Global
Biodiversity Information Facility (GBIF)</a>. The
<code>speciaLists</code> is a dataset with specialists of ferns and
lycophytes of Brazil, which we gathered from the authors of this <a href="https://doi.org/10.1590/2175-7860201566410">paper</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># Load package and data</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">library</span>(naturaList)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;A.setosa&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;speciaLists&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co"># see the size of datasets</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="fu">dim</span>(A.setosa) <span class="co"># see ?A.setosa for details</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="fu">dim</span>(speciaLists) <span class="co"># see ?speciaLists for details</span></span></code></pre></div>
<p>Classification using the default order of confidence levels</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># classification</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>occ.class <span class="ot">&lt;-</span> <span class="fu">classify_occ</span>(A.setosa, speciaLists)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="fu">dim</span>(occ.class)</span></code></pre></div>
<p>You can check how many occurrences was classified in each level:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">table</span>(occ.class<span class="sc">$</span>naturaList_levels)</span></code></pre></div>
</div>
<div id="create-a-specialist-dataset" class="section level2">
<h2>Create a specialist dataset</h2>
<p>You can easily create a specialist dataset using
<code>create_spec_df()</code>. You just need to provide a character
vector with the names of specialists, and the output is a dataset
formatted be used in <code>classify_occ()</code>.</p>
<p>In this example, we use the names of four famous Brazilian musicians.
Note that the Latin accent mark is provided, and even a nickname
(e.g. Tom Jobim).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># create a specialist table example</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>br.musicians <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Caetano Veloso&quot;</span>, <span class="st">&quot;Antônio Carlos Tom Jobim&quot;</span>, </span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                  <span class="st">&quot;Gilberto Gil&quot;</span>, <span class="st">&quot;Vinícius de Morais&quot;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>spec_df <span class="ot">&lt;-</span> <span class="fu">create_spec_df</span>(br.musicians)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>spec_df</span></code></pre></div>
</div>
<div id="verify-if-the-strings-in-the-identifiedby-column-of-occurrence-dataset-is-a-name" class="section level2">
<h2>Verify if the strings in the ‘identifiedBy’ column of occurrence
dataset is a name</h2>
<p>It might occur that some strings in the ‘identifiedBy’ column of the
occurrence dataset do not correspond to a taxonomist name. Strings as
such <code>&quot;Unknown&quot;</code> often is included in the ‘identifiedBy’ data
field. It is important then that such strings be ignored by the
<code>classify_occ()</code>, if not this function could flag an
occurrence record as determined by a taxonomist when it was not.</p>
<p>To cope with this issue, <code>get_det_names()</code> can be used to
verify which strings are not taxonomists names. This function returns
all unique strings in the ‘identifiedBy’ column of the dataset. Based on
this list of names, you could create a character vector with the strings
to be ignored by <code>classify_occ()</code>, providing it to the
<code>ignore.det.names</code> argument. See also the
<code>?classify_occ</code> for more details.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co"># check out if there are strings which are not taxonomists</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="fu">get_det_names</span>(A.setosa)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co"># include these strings in a object</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>ig.names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Sem Informação&quot;</span> , <span class="st">&quot;Anonymous&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co"># use &#39;ignore.det.names&#39; to ignore those strings in classify_occ()</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>occ.class <span class="ot">&lt;-</span> <span class="fu">classify_occ</span>(A.setosa, speciaLists, <span class="at">ignore.det.names =</span> ig.names)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="fu">table</span>(occ.class<span class="sc">$</span>naturaList_levels)</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
